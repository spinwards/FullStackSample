{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Observable, of, Subject } from 'rxjs';\nimport { Injectable, defineInjectable } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @abstract\n * @template T\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nclass DataSource {}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * DataSource wrapper for a native array.\n * @template T\n */\n\n\nclass ArrayDataSource extends DataSource {\n  /**\n   * @param {?} _data\n   */\n  constructor(_data) {\n    super();\n    this._data = _data;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  connect() {\n    return this._data instanceof Observable ? this._data : of(this._data);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  disconnect() {}\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Class to be used to power selecting one or more options from a list.\n * @template T\n */\n\n\nclass SelectionModel {\n  /**\n   * @param {?=} _multiple\n   * @param {?=} initiallySelectedValues\n   * @param {?=} _emitChanges\n   */\n  constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\n    this._multiple = _multiple;\n    this._emitChanges = _emitChanges;\n    /**\n     * Currently-selected values.\n     */\n\n    this._selection = new Set();\n    /**\n     * Keeps track of the deselected options that haven't been emitted by the change event.\n     */\n\n    this._deselectedToEmit = [];\n    /**\n     * Keeps track of the selected options that haven't been emitted by the change event.\n     */\n\n    this._selectedToEmit = [];\n    /**\n     * Event emitted when the value has changed.\n     */\n\n    this.changed = new Subject();\n    /**\n     * Event emitted when the value has changed.\n     * @deprecated Use `changed` instead.\n     * \\@breaking-change 8.0.0 To be changed to `changed`\n     */\n\n    this.onChange = this.changed;\n\n    if (initiallySelectedValues && initiallySelectedValues.length) {\n      if (_multiple) {\n        initiallySelectedValues.forEach(value => this._markSelected(value));\n      } else {\n        this._markSelected(initiallySelectedValues[0]);\n      } // Clear the array in order to avoid firing the change event for preselected values.\n\n\n      this._selectedToEmit.length = 0;\n    }\n  }\n  /**\n   * Selected values.\n   * @return {?}\n   */\n\n\n  get selected() {\n    if (!this._selected) {\n      this._selected = Array.from(this._selection.values());\n    }\n\n    return this._selected;\n  }\n  /**\n   * Selects a value or an array of values.\n   * @param {...?} values\n   * @return {?}\n   */\n\n\n  select(...values) {\n    this._verifyValueAssignment(values);\n\n    values.forEach(value => this._markSelected(value));\n\n    this._emitChangeEvent();\n  }\n  /**\n   * Deselects a value or an array of values.\n   * @param {...?} values\n   * @return {?}\n   */\n\n\n  deselect(...values) {\n    this._verifyValueAssignment(values);\n\n    values.forEach(value => this._unmarkSelected(value));\n\n    this._emitChangeEvent();\n  }\n  /**\n   * Toggles a value between selected and deselected.\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  toggle(value) {\n    this.isSelected(value) ? this.deselect(value) : this.select(value);\n  }\n  /**\n   * Clears all of the selected values.\n   * @return {?}\n   */\n\n\n  clear() {\n    this._unmarkAll();\n\n    this._emitChangeEvent();\n  }\n  /**\n   * Determines whether a value is selected.\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  isSelected(value) {\n    return this._selection.has(value);\n  }\n  /**\n   * Determines whether the model does not have a value.\n   * @return {?}\n   */\n\n\n  isEmpty() {\n    return this._selection.size === 0;\n  }\n  /**\n   * Determines whether the model has a value.\n   * @return {?}\n   */\n\n\n  hasValue() {\n    return !this.isEmpty();\n  }\n  /**\n   * Sorts the selected values based on a predicate function.\n   * @param {?=} predicate\n   * @return {?}\n   */\n\n\n  sort(predicate) {\n    if (this._multiple && this.selected) {\n      /** @type {?} */\n      this._selected.sort(predicate);\n    }\n  }\n  /**\n   * Gets whether multiple values can be selected.\n   * @return {?}\n   */\n\n\n  isMultipleSelection() {\n    return this._multiple;\n  }\n  /**\n   * Emits a change event and clears the records of selected and deselected values.\n   * @return {?}\n   */\n\n\n  _emitChangeEvent() {\n    // Clear the selected values so they can be re-cached.\n    this._selected = null;\n\n    if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n      this.changed.next({\n        source: this,\n        added: this._selectedToEmit,\n        removed: this._deselectedToEmit\n      });\n      this._deselectedToEmit = [];\n      this._selectedToEmit = [];\n    }\n  }\n  /**\n   * Selects a value.\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  _markSelected(value) {\n    if (!this.isSelected(value)) {\n      if (!this._multiple) {\n        this._unmarkAll();\n      }\n\n      this._selection.add(value);\n\n      if (this._emitChanges) {\n        this._selectedToEmit.push(value);\n      }\n    }\n  }\n  /**\n   * Deselects a value.\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  _unmarkSelected(value) {\n    if (this.isSelected(value)) {\n      this._selection.delete(value);\n\n      if (this._emitChanges) {\n        this._deselectedToEmit.push(value);\n      }\n    }\n  }\n  /**\n   * Clears out the selected values.\n   * @return {?}\n   */\n\n\n  _unmarkAll() {\n    if (!this.isEmpty()) {\n      this._selection.forEach(value => this._unmarkSelected(value));\n    }\n  }\n  /**\n   * Verifies the value assignment and throws an error if the specified value array is\n   * including multiple values while the selection model is not supporting multiple values.\n   * @param {?} values\n   * @return {?}\n   */\n\n\n  _verifyValueAssignment(values) {\n    if (values.length > 1 && !this._multiple) {\n      throw getMultipleValuesInSingleSelectionError();\n    }\n  }\n\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getMultipleValuesInSingleSelectionError() {\n  return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\n\n\nclass UniqueSelectionDispatcher {\n  constructor() {\n    this._listeners = [];\n  }\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param {?} id ID of the item.\n   * @param {?} name Name of the item.\n   * @return {?}\n   */\n\n\n  notify(id, name) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n  /**\n   * Listen for future changes to item selection.\n   * @param {?} listener\n   * @return {?} Function used to deregister listener\n   */\n\n\n  listen(listener) {\n    this._listeners.push(listener);\n\n    return () => {\n      this._listeners = this._listeners.filter(registered => {\n        return listener !== registered;\n      });\n    };\n  }\n  /**\n   * @return {?}\n   */\n\n\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n\n}\n\nUniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) {\n  return new (t || UniqueSelectionDispatcher)();\n};\n\nUniqueSelectionDispatcher.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: UniqueSelectionDispatcher,\n  factory: UniqueSelectionDispatcher.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nUniqueSelectionDispatcher.ngInjectableDef = /*#__PURE__*/defineInjectable({\n  factory: function UniqueSelectionDispatcher_Factory() {\n    return new UniqueSelectionDispatcher();\n  },\n  token: UniqueSelectionDispatcher,\n  providedIn: \"root\"\n});\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { UniqueSelectionDispatcher, ArrayDataSource, DataSource, getMultipleValuesInSingleSelectionError, SelectionModel }; //# sourceMappingURL=collections.js.map","map":null,"metadata":{},"sourceType":"module"}